
-- CREATE TABLE user_profile (
--   id UUID REFERENCES auth.users ON DELETE CASCADE PRIMARY KEY,
--   username VARCHAR(30) UNIQUE,
--   points INT DEFAULT 250 CHECK(points >= 0),
--   created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
--   last_active TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
--   avatar_url TEXT,
--   country_of_origin VARCHAR(50),
--   total_quizzes_taken INT DEFAULT 0,
--   total_correct_answers INT DEFAULT 0,
--   total_incorrect_answers INT DEFAULT 0,
--   updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
--   is_admin BOOLEAN DEFAULT FALSE
-- );


/* Aggregated User Statistics: */

-- CREATE TABLE user_stats (
--     user_id UUID PRIMARY KEY REFERENCES user_profile(id) ON DELETE CASCADE,
--     total_questions_answered INT DEFAULT 0,
--     total_hints_used INT DEFAULT 0,
--     total_time_spent_seconds BIGINT DEFAULT 0,
--     total_quizzes_taken INT DEFAULT 0,
--     total_correct_answers INT DEFAULT 0,
--     total_incorrect_answers INT DEFAULT 0,
--     avg_time_per_question FLOAT DEFAULT 0,
--     avg_questions_per_quiz FLOAT DEFAULT 0,
--     avg_hints_per_quiz FLOAT DEFAULT 0,
--     hints_usage_ratio FLOAT DEFAULT 0,
--     correct_ratio FLOAT DEFAULT 0,
--     incorrect_ratio FLOAT DEFAULT 0,
--     longest_streak INT DEFAULT 0,
--     updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
-- );

-- CREATE TABLE user_stats_daily (
--   user_id UUID REFERENCES user_profile(id) ON DELETE CASCADE,
--   date DATE NOT NULL,
--   questions_answered INT DEFAULT 0,
--   hints_used INT DEFAULT 0,
--   time_spent_seconds BIGINT DEFAULT 0,
--   quizzes_taken INT DEFAULT 0,
--   correct_answers INT DEFAULT 0,
--   incorrect_answers INT DEFAULT 0,

--   PRIMARY KEY (user_id, date)
-- );


-- CREATE TABLE questions (
--     question_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
--     country_id INT NOT NULL,
--     question_text TEXT NOT NULL,
--     correct_answer TEXT[] NOT NULL,
--     question_img TEXT,
--     FOREIGN KEY(country_id) REFERENCES countries(country_id)
-- );


-- CREATE TABLE question_choices (
--     question_choice_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
--     question_id INT NOT NULL,
--     label CHAR(1) NOT NULL CHECK(label IN ('A', 'B', 'C', 'D', 'E', 'F')),
--     choice_text TEXT NOT NULL,
--     is_correct BOOLEAN NOT NULL,
--     FOREIGN KEY(question_id) REFERENCES questions(question_id) ON DELETE CASCADE
-- );


-- CREATE TABLE question_subcategory (
--     question_id INT NOT NULL,
--     subcategory_id INT NOT NULL,
--     PRIMARY KEY (question_id, subcategory_id),
--     FOREIGN KEY (question_id) REFERENCES questions(question_id) ON DELETE CASCADE,
--     FOREIGN KEY (subcategory_id) REFERENCES subcategories(subcategory_id) ON DELETE CASCADE
-- );


-- CREATE TABLE question_facts (
--     fact_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
--     question_id INT NOT NULL,
--     fact_text TEXT NOT NULL,
--     FOREIGN KEY(question_id) REFERENCES questions(question_id) ON DELETE CASCADE
-- );


-- CREATE TABLE quiz_sessions (
--     session_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
--     user_id UUID NOT NULL,
--     subcategory_id INT NOT NULL,
--     difficulty TEXT CHECK(difficulty IN ('easy', 'medium', 'hard')) NOT NULL,
--     num_questions INT NOT NULL,
--     with_dependencies BOOLEAN DEFAULT FALSE,
--     total_correct INT NULL,
--     total_incorrect INT NULL,
--     used_hints_count INT DEFAULT 0,
--     base_points INT DEFAULT 0,
--     hint_penalty INT DEFAULT 0,
--     total_points INT GENERATED ALWAYS AS (
--         GREATEST(0, base_points - hint_penalty)
--     ) STORED,
--     started_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
--     completed_at TIMESTAMPTZ CHECK(completed_at >= started_at),
--     time_taken_seconds INT GENERATED ALWAYS AS (
--         CASE WHEN completed_at IS NULL THEN NULL
--         ELSE EXTRACT(EPOCH FROM (completed_at - started_at))::INT
--         END
--     ) STORED,
--     FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE,
--     FOREIGN KEY (subcategory_id) REFERENCES subcategories(subcategory_id) ON DELETE RESTRICT
-- );


-- CREATE TABLE quiz_questions (
--     quiz_question_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
--     session_id UUID NOT NULL,
--     question_id INT NOT NULL,
--     user_answer TEXT,
--     is_correct BOOLEAN,
--     correct_answer TEXT[] NOT NULL,
--     is_hint_used BOOLEAN,
--     hints_used INT DEFAULT 0,
--     attempts INT DEFAULT 1,
--     answer_time_seconds INT DEFAULT 0 CHECK(answer_time_seconds >= 0),
--     question_order INT NOT NULL DEFAULT 0,
--     FOREIGN KEY (session_id) REFERENCES quiz_sessions(session_id) ON DELETE CASCADE,
--     FOREIGN KEY (question_id) REFERENCES questions(question_id) ON DELETE RESTRICT
-- );

-- answer_time jest liczony poprzez stronę aplikacji w backendzie w następujący sposób:
-- gdy pytanie zostanie wyświetlone, zapisywana jest wartość shownAt jako: shownAt = new Date()
-- gdy użytkownik zakończy odpowiadanie, zapisywana jest wartość answeredAt jako: answeredAt = new Date()
-- wartość do kolumny answer_time jest obliczana jako różnica: answeredAt - shownAt (w postaci sekund) 


-- CREATE TABLE country_shapes (
--     shape_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
--     country_id INT,
--     geom geometry(MultiPolygon, 4326),
--     FOREIGN KEY (country_id) REFERENCES countries(country_id)
-- );


-- CREATE TABLE user_favorites (
--   favorite_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
--   user_id UUID REFERENCES user_profile(id) ON DELETE CASCADE,
--   subcategory_id INT REFERENCES subcategories(subcategory_id) ON DELETE CASCADE,
--   created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
--   UNIQUE(user_id, subcategory_id)
-- );


-- CREATE TABLE news (
--   news_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
--   title TEXT NOT NULL,
--   description TEXT,
--   image_url TEXT,
--   category TEXT DEFAULT 'general',
--   examples TEXT,
--   created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
-- );


-- CREATE TABLE achievements (
--   achievement_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
--   title TEXT NOT NULL,
--   description TEXT,
--   icon TEXT,
--   condition_type TEXT NOT NULL,
--   condition_value INT NOT NULL,
--   points INT DEFAULT 0,
--   category TEXT DEFAULT 'COMMON' CHECK(category IN ('COMMON', 'RARE', 'LEGENDARY')),
--   created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
-- );


-- CREATE TABLE user_achievement (
--   user_id UUID REFERENCES user_profile(id) ON DELETE CASCADE,
--   achievement_id INT REFERENCES achievements(achievement_id) ON DELETE CASCADE,
--   earned_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
--   PRIMARY KEY(user_id, achievement_id)
-- );

CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.user_profile (id, username, points, avatar_url)
  VALUES (new.id, new.raw_user_meta_data->>'username', 250, '/default_avatar.svg');
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();


SELECT
  cs2.country_id,
  c.country_name,
  ST_Area(cs2.geom::geography) / 1000000 AS area,
  COUNT(cs2.*) OVER() AS neighbours
FROM country_shapes cs1
JOIN country_shapes cs2
  ON ST_Intersects(cs1.geom, cs2.geom)
  AND cs1.country_id <> cs2.country_id
JOIN countries c
  ON cs2.country_id = c.country_id
WHERE cs1.country_id = 61;

SELECT
  ARRAY['PL']::TEXT[] <@ ARRAY['DE', 'PL', 'FR']::TEXT[];
-- @> oznacza: czy A zawiera B
-- <@ ozancza: czy A jest podzbiorem B

-- Assign a global subcategory
INSERT INTO question_subcategory (question_id, subcategory_id)
SELECT generate_series(742, 988), 17;

-- Assign an appropriate subcategory based on country and its continent
INSERT INTO question_subcategory (question_id, subcategory_id)
SELECT
    q.question_id,
    CASE con.continent_name
        WHEN 'Europe' THEN 18
        WHEN 'Asia' THEN 19
        WHEN 'Africa' THEN 20
        WHEN 'Oceania' THEN 21
        WHEN 'North America' THEN 22
        WHEN 'South America' THEN 23
        ELSE NULL
    END AS subcategory_id
FROM questions q
JOIN countries cou
  ON q.country_id = cou.country_id
JOIN country_continent cc
  ON cou.country_id = cc.country_id
JOIN continents con
  ON cc.continent_id = con.continent_id
WHERE q.question_id BETWEEN 742 AND 988;

-- Assign an appropriate subcategory for dependent territories only
INSERT INTO question_subcategory (question_id, subcategory_id)
SELECT
    q.question_id, (
        SELECT
            subcategory_id
        FROM subcategories
        WHERE subcategory_name = 'Country Outlines: Dependent Territories'
    ) AS subcategory_id
FROM questions q
JOIN countries cou
  ON q.country_id = cou.country_id
WHERE q.question_id BETWEEN 742 AND (
    SELECT
        MAX(question_id)
    FROM questions 
)
  AND cou.type = 'territory';

-- Assign an appropriate region for subcategory based on the subcategory_name:
UPDATE subcategories
SET region = CASE
    WHEN subcategory_name ILIKE '%africa%' THEN 'Africa'
    WHEN subcategory_name ILIKE '%asia%' THEN 'Asia'
    WHEN subcategory_name ILIKE '%europe%' THEN 'Europe'
    WHEN subcategory_name ILIKE '%north america%' THEN 'North America'
    WHEN subcategory_name ILIKE '%south america%' THEN 'South America'
    WHEN subcategory_name ILIKE '%oceania%' THEN 'Oceania'
    WHEN subcategory_name ILIKE '%territor%' THEN 'Dependent Territories'
    WHEN subcategory_name ILIKE '%world%' THEN 'World'
  ELSE NULL
END
WHERE region IS NULL;







